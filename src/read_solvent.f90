!===================================================================================================================================
SUBROUTINE read_solvent
!===================================================================================================================================
! Read solvent atomic positions, charge, and lennard jones values in solvent.in
! charge in electron units, sigma in Angstroms, epsilon in KJ/mol.

use precision_kinds, only: i2b , dp, sp
use system, only: solvent
use mathematica, only: chop
use module_input, only: getinput

IMPLICIT NONE

INTEGER(i2b) :: n, ios, i, j, k, l, s, d

OPEN(5, FILE= 'input/solvent.in', STATUS= 'old', IOSTAT= ios )! open input/solvent.in and check if it is readable
    IF ( ios/=0 ) STOP 'ERROR: solvent.in can not be opened.'
    READ (5,*) solvent(1)%name
    READ (5,*) solvent(1)%nsite!, solvent(1)%molrotsymorder
    i = solvent(1)%nsite
    allocate (solvent(1)%site(i), stat=ios)
    if (ios /= 0) stop "ERROR: wrong allocate of solvent%site in read_solvent.f90"
    READ(5,*) ! comment line
    DO n = 1 , size(solvent(1)%site)
        READ(5,*) i, solvent(1)%site(n)%q, solvent(1)%site(n)%sig, solvent(1)%site(n)%eps, solvent(1)%site(n)%r
        if (i/=n) then
            print*, "in solvent.in, index in first column is very strange for site number", n
            stop "have a look at read_solvent.f90"
        end if
    END DO
CLOSE(5)

!... compute monopole, dipole, quadrupole, octupole and hexadecapole of each solvent species
!... 1 Debye (D)  = 3.33564095 x10-30 C·m (= -0.20819435 e-·Å)
do concurrent (s=1:size(solvent))
    !... monopole = net charge
    solvent(s)%monopole = chop(sum( solvent(s)%site%q ))

    !... dipole
    do concurrent (i=1:3)
        solvent(s)%dipole(i) = chop(sum( solvent(s)%site%q * solvent(s)%site%r(i) ))
    end do

    !... quadrupole
    do concurrent (i=1:3, j=1:3)
        solvent(s)%quadrupole(i,j) = chop(sum( solvent(s)%site%q * solvent(s)%site%r(i) * solvent(s)%site%r(j) ))
    end do

    !... octupole
    do concurrent (i=1:3, j=1:3, k=1:3)
        solvent(s)%octupole(i,j,k) = chop(&
            sum( solvent(s)%site%q * solvent(s)%site%r(i) * solvent(s)%site%r(j) * solvent(s)%site%r(k) ))
    end do

    !... hexadecapole
    do concurrent (i=1:3, j=1:3, k=1:3, l=1:3)
        solvent(s)%hexadecapole(i,j,k,l) = chop( sum( solvent(s)%site%q * &
            solvent(s)%site%r(i) * solvent(s)%site%r(j) * solvent(s)%site%r(k) * solvent(s)%site%r(l) ))
    end do
end do

! Compute the charge density of a single solvant molecule in Fourier-space, and electrostatic potential generated by a such distribution
block
    character(180) :: polarization
    polarization = getinput%char("polarization", defaultvalue="no")
    select case (polarization)
    case("no","none")
    case("dipolar", "multipolar_without_coupling_to_density", "multipolar_with_coupling_to_density")
        call chargeDensityAndMolecularPolarizationOfASolventMoleculeAtOrigin
    case default
        print*, "The tag 'polarization' in input reads ", polarization,". This is not correct"
        stop "in read_solvent.f90"
    end select
end block


contains

    !This routine compute : -The solvent molecular charge density, which can be used into Vcoul_from_solvent_charge_density.f90 to
    !evaluate the electrostatic potential.
    !                       -The solvent molecular polarization (from Ranieriet al : J. Chem. Phys. 98 (11) 1993) that can be used
    !into energy_polarization_..._.f90 to compute the (multipolar) polarization Free energy.

    subroutine chargeDensityAndMolecularPolarizationOfASolventMoleculeAtOrigin

        use precision_kinds     ,ONLY: dp
        use system              ,ONLY: solvent
        use fft                 ,ONLY: kx, ky, kz, k2
        !use mathematica         ,ONLY: factorial
        use module_grid, only: grid

        implicit none

        integer :: nx, ny, nz, no, ns
        integer :: i, j, k, n, s, io
        real(dp)     :: r(3), kr, kvec(3)
        complex(dp)  :: fac, X
        complex(dp), parameter :: zeroc = cmplx(0._dp,0._dp), ic = cmplx(0._dp,1._dp)
        real(dp), parameter :: epsdp = epsilon(1._dp)
        type :: smoother_type
            real(dp) :: radius = 0.5_dp ! dramaticaly important
            real(dp) :: factor
        end type smoother_type
        type (smoother_type) :: smoother

        nx = grid%nx
        ny = grid%ny
        nz = grid%nz
        no = grid%no
        ns = solvent(1)%nspec

        ! sigma_k is the Fourier transformed charge density of a single solvent molecule in the reference frame defined by solvent.in
        ! molec_polar_k is the Fourier transformed molecular polarization
        do concurrent( s=1:ns , sum(abs(solvent(s)%site%q))>0) ! mask elimitates solvent molecules without point charges
            allocate( solvent(s)%sigma_k       (   nx/2+1, ny, nz, no), SOURCE=zeroC )
            allocate( solvent(s)%molec_polar_k (3, nx/2+1, ny, nz, no), SOURCE=zeroC )
        end do

        do concurrent ( i=1:nx/2+1, j=1:ny, k=1:nz, s=1:ns  , sum(abs(solvent(s)%site%q))>epsdp) ! mask elimitates solvent molecules without point charges)

            kvec = [ kx(i), ky(j), kz(k) ]
            smoother%factor =  exp(-smoother%radius**2 *k2(i,j,k)/2)

            do concurrent ( io=1:grid%no, n=1:SIZE(solvent(s)%site), abs(solvent(s)%site(n)%q)>epsdp )
                r(1) = dot_product(   [grid%Rotxx(io),grid%Rotxy(io),grid%Rotxz(io)]  ,  solvent(s)%site(n)%r  )
                r(2) = dot_product(   [grid%Rotyx(io),grid%Rotyy(io),grid%Rotyz(io)]  ,  solvent(s)%site(n)%r  )
                r(3) = dot_product(   [grid%Rotzx(io),grid%Rotzy(io),grid%Rotzz(io)]  ,  solvent(s)%site(n)%r  )
                kr = dot_product( kvec, r )
                X = -iC*kr
                solvent(s)%sigma_k(i,j,k,io) = solvent(s)%sigma_k(i,j,k,io) + solvent(s)%site(n)%q *exp(X) *smoother%factor ! exact
                ! solvent(s)%sigma_k(i,j,k,o,p) = solvent(s)%sigma_k(i,j,k,o,p) +solvent(s)%site(n)%q* sum([(X**i/factorial(i), i=0,4)])&
                ! * smoother%factor ! Series expansion of exp(x) at 0 => multipole expansion of Vcoul(x). i=4 :: hexadecapole (16)
                if ( abs(kr)<=epsdp ) then
                    solvent(s)%molec_polar_k(:,i,j,k,io) = solvent(s)%molec_polar_k(:,i,j,k,io) + solvent(s)%site(n)%q *r
                else
                    fac = -iC*(exp(iC*kr)-1._dp)/kr *smoother%factor
                    solvent(s)%molec_polar_k(:,i,j,k,io) = solvent(s)%molec_polar_k(:,i,j,k,io) + fac*solvent(s)%site(n)%q *r
                end if
            end do
        end do

        !
        ! Substract the trace of the molecular polarization tensor
        !
        do concurrent (i=1:nx/2+1, j=1:ny, k=1:nz, s=1:ns, d=1:3)
            solvent(s)%molec_polar_k(d,i,j,k,:) = solvent(s)%molec_polar_k(d,i,j,k,:)  &
                -sum( solvent(s)%molec_polar_k(d,i,j,k,:) ) /real(grid%no,dp)
        end do
    end subroutine chargeDensityAndMolecularPolarizationOfASolventMoleculeAtOrigin

END SUBROUTINE read_solvent
