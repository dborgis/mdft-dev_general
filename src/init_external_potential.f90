! This subroutine computes the external potential. It is one of the most time consuming routine.
!Warning there are two ways of calculating the electrostatic potential (Poisson solver and point charge) you should always have one tag
!T and one tag F for the electrostatic potential, if thera are 2 tags T, it is the last evaluation which counts, i.e Poisson solver. 
subroutine init_external_potential
    use precision_kinds , only : dp , i2b
    use input , only : input_line , input_log,input_char
    use system , only : chg_mol , chg_solv , eps_solv , eps_mol , sig_solv , sig_mol , Lx , Ly , Lz , nb_omega , nb_psi , &
                    nfft1 , nfft2 , nfft3 , nb_species
    use external_potential, only: Vext_total, Vext_q
    use mod_lj, only: initLJ => init


implicit none
integer ( kind = i2b ) :: nb_id_mol , nb_id_solv ! nb of types of sites of solute and solvent
integer ( kind = i2b ) , parameter :: nrgrid = 100000 ! nb of point of the radial grid for tabulation of the potentials TODO magic number here ...
real ( kind = dp ) :: drgrid ! distance between two points in radial grid (in Angstroms) =abs(rcut-rmin)/nrgrid
real ( kind = dp ) :: drgrid2 ! distance between two point in radial**2 grid
real ( kind = dp ) , allocatable , dimension ( : , : , : ) ::  tabulated_coulsq
real ( kind = dp ) , dimension ( nb_omega , nb_psi ) :: Rotxx , Rotxy , Rotxz , Rotyx , Rotyy , Rotyz , Rotzx , Rotzy , Rotzz
integer ( kind = i2b ) :: i , j ! dummy

! init vext which is in module system
if (.not. allocated ( Vext_total) ) allocate ( Vext_total ( nfft1 , nfft2 , nfft3 , nb_omega , nb_psi, nb_species ) ) ! multispec
Vext_total = 0.0_dp

! generate tabulated potentials
! call tabulate_potentials TODO Latter it will be worse splitting init_external_potential in different subroutines called from here

! init tabulation properties
nb_id_mol  = size ( chg_mol  ) ! total number of solute types
nb_id_solv = size ( chg_solv ) ! total number of solvent types
drgrid  =   3._dp* max ( Lx , Ly , Lz ) * sqrt ( 3.0_dp ) * 2.0_dp / real ( nrgrid , kind=dp) ! distance between two grid points for tabulation
drgrid2 = ( 3._dp * max ( Lx , Ly , Lz ) * sqrt ( 3.0_dp ) ) ** 2 * 2.0_dp / real( nrgrid ,kind=dp) ! distance **2 between two grid points

!test if GL quadrature is used

if (trim(adjustl(input_char('quadrature'))) == 'GL') then
  call compute_angular_grid ( Rotxx , Rotxy , Rotxz , Rotyx , Rotyy , Rotyz , Rotzx , Rotzy , Rotzz ) ! Gauss Legendre integration for angular integrations & 
end if
if (trim(adjustl(input_char('quadrature'))) == 'L') then
  call compute_angular_grid_leb ( Rotxx , Rotxy , Rotxz , Rotyx , Rotyy , Rotyz , Rotzx , Rotzy , Rotzz )   ! Lebedev integration for angular integrations &
end if


  !call get_charge_factor ( Rotxx,Rotxy,Rotxz,Rotyx,Rotyy,Rotyz,Rotzx,Rotzy,Rotzz )
!If we microscopic description of solvent compute charge density in k space and electrostatic potential generated by a such distribution

if (trim(adjustl(input_char('evaluate_polarization'))) == 'multi') then
  call get_charge_density_k ( Rotxx,Rotxy,Rotxz,Rotyx,Rotyy,Rotyz,Rotzx,Rotzy,Rotzz )  
end if


!!> Compute pseudopotential
!allocate(Vpseudo(nfft1,nfft2,nfft3,nb_omega))
!call compute_vpseudo_ijko

! potential created by hard wall(s)
call external_potential_hard_walls


if (input_log('point_charge_electrostatic')) then
  write (*,*) 'je passe dans le ponctuel'
  !> Compute Vcoul(i,j,k,omega)
  if (.not. allocated(Vext_q) ) allocate ( Vext_q ( nfft1 , nfft2 , nfft3 , nb_omega , nb_psi, nb_species ) )
    Vext_q = 0.0_dp
    call compute_vcoul_ijko_from_tabulated ( nrgrid , drgrid2 , nb_id_solv , nb_id_mol , &
                                       Rotxx , Rotxy , Rotxz , Rotyx , Rotyy , Rotyz , Rotzx , Rotzy , Rotzz , &
                                      tabulated_coulsq )
end if


!Check if you want to calculate the electrostatic potential by using "poisson_solver"
! Poisson solver
if (input_log('poisson_solver')) then
  if (.not. allocated(Vext_q) ) allocate ( Vext_q ( nfft1 , nfft2 , nfft3 , nb_omega, nb_psi , nb_species ) )
  Vext_q=0.0_dp
  call electrostatic_potential_from_charge_density ! Electrostatic potential using FFT of Poisson equation Laplacian(V(r))= - charge_density / Epsilon_0
  call vext_q_from_v_c (Rotxx,Rotxy,Rotxz,Rotyx,Rotyy,Rotyz,Rotzx,Rotzy,Rotzz)
  print*, 'je passe dans le PS'
end if

call initLJ
! and finaly compute it
!call compute_vlj_ijko_from_tabulated ( nrgrid , drgrid2 , nb_id_solv , nb_id_mol  )
! deallocate the tabulated values of Vext_lj(r) and Vext_lj(r**2)
!if ( allocated ( tabulated_ljsq ) ) deallocate ( tabulated_ljsq )



!compute purely repulsive potential in 1/r12
if (input_log('purely_repulsive_solute')) then
    call compute_purely_repulsive_potential ( Rotxx , Rotxy , Rotxz , Rotyx , Rotyy , Rotyz , Rotzx , Rotzy , Rotzz )
end if

! compute potential created by hard sphere solute if present

if (input_log('hard_sphere_solute')) then
  call compute_vext_hard_sphere
end if

! potential created by hard wall(s)
call external_potential_hard_walls

! compute potential created by hard cylinder solute if present
if (input_log('hard_cylinder_solute')) then
    call compute_vext_hard_cylinder
end if

!! compute potential created by a hard square well if present
!do i = 1 , size ( input_line )
!  j = len ( 'vext_hard_square_well' )
!  if ( input_line (i) (1:j) == 'vext_hard_square_well' .and. input_line (i) (j+4:j+4) == 'T' ) call vext_hard_square_well
!end do

! compute the personnal vext as implemented in personnal_vext.f90. first check existence.
if (input_log('personnal_vext')) then
    call compute_vext_perso
end if

! compute total Vext(i,j,k,omega), the one used in the free energy functional
call vext_total_sum

end subroutine init_external_potential
